private static ConcurrentMap<String, Map<String, Double>> predictRatingsMatrix(ConcurrentLinkedQueue<Rating> ratings)
            throws InterruptedException {

        // Agrupar ratings por usuário
        ConcurrentMap<String, ConcurrentLinkedQueue<Rating>> ratingsByUser = new ConcurrentHashMap<>();
        for (Rating r : ratings) {
            ratingsByUser
                    .computeIfAbsent(r.getUserId(), k -> new ConcurrentLinkedQueue<>())
                    .add(r);
        }

        // Matriz final
        ConcurrentMap<String, Map<String, Double>> matrix = new ConcurrentHashMap<>();

        // Configuração de platform threads com chunking
        int numThreads = Math.max(2, Runtime.getRuntime().availableProcessors());
        int chunkSize = (int) Math.ceil(allUsers.size() / (double) numThreads);
        List<List<String>> userChunks = splitList(new ArrayList<>(allUsers), chunkSize);

        ExecutorService executor = Executors.newFixedThreadPool(numThreads, Thread.ofPlatform().factory());
        List<Callable<Void>> tasks = new ArrayList<>();

        for (List<String> chunk : userChunks) {
            tasks.add(() -> {
                for (String user : chunk) {
                    Map<String, Double> ratingsForUser = new ConcurrentHashMap<>();
                    ConcurrentLinkedQueue<Rating> userRatings = ratingsByUser.getOrDefault(user, new ConcurrentLinkedQueue<>());

                    // Copiar avaliações reais
                    for (Rating r : userRatings) {
                        ratingsForUser.put(r.getTitle(), r.getRating());
                    }

                    // Predizer ausentes
                    for (Rating r : ratings) {
                        if (!ratingsForUser.containsKey(r.getTitle())) {
                            double predicted = 0.0;
                            for (String genre : r.getGenres()) {
                                predicted += dot(userFactors.get(user), genreFactors.get(genre));
                            }
                            predicted /= r.getGenres().size();
                            ratingsForUser.put(r.getTitle(), predicted);
                        }
                    }

                    matrix.put(user, ratingsForUser); // pode ser sincronizado depois se necessário
                }
                return null;
            });
        }

        executor.invokeAll(tasks);
        executor.shutdown();

        return matrix;
    }
